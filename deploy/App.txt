<!DOCTYPE html>
<html>
<head>
    <title>Portfolio Kanban Using Alternate Field</title>
    <!--  (c) 2015 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Tue Jul 07 2015 09:51:55 GMT-0700 (PDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Tue Jul 07 2015 09:51:55 GMT-0700 (PDT)";
        var CHECKSUM = 15645517200;
    </script>
    
    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('Rally.apps.common.PortfolioItemsGridBoardApp', {
    extend: 'Rally.app.GridBoardApp',
    requires: [
        'Rally.ui.cardboard.plugin.CollapsibleColumns',
        'Rally.ui.cardboard.plugin.FixedHeader'
    ],

    launch: function () {
        if (Rally.environment.getContext().getSubscription().isModuleEnabled('Rally Portfolio Manager')) {
            this.callParent(arguments);
        } else {
            this.add({
                xtype: 'container',
                html: '<div class="rpm-turned-off" style="padding: 50px; text-align: center;">You do not have RPM enabled for your subscription</div>'
            });

            this.publishComponentReady();
        }
    },

    loadModelNames: function () {
        return this._createPITypePicker().then({
            success: function (selectedType) {
                this.currentType = selectedType;
                return [selectedType.get('TypePath')];
            },
            scope: this
        });
    },

    addGridBoard: function () {
        if (this.gridboard && this.piTypePicker && this.piTypePicker.rendered) {
            this.piTypePicker.up().remove(this.piTypePicker, false);
        }
        this.callParent(arguments);
    },

    getHeaderControls: function () {
        return this.callParent(arguments).concat(this.piTypePicker);
    },

    getFilterControlConfig: function () {
        return {
            blackListFields: ['PortfolioItemType'],
            whiteListFields: ['Milestones']
        };
    },

    getFieldPickerConfig: function () {
        var blackListedFields = [];

        if(!this.getContext().isFeatureEnabled('S74502_PI_DEPENDENCIES_ON_EDP')) {
            blackListedFields.push('PredecessorsAndSuccessors');
        }
        return _.merge(this.callParent(arguments), {
            boardFieldDefaults: (this.getSetting('fields') || '').split(','),
            boardFieldBlackList: ['Predecessors', 'Successors'].concat(blackListedFields),
            gridFieldBlackList: blackListedFields,
            margin: '3 9 14 0'
        });
    },

    getCardBoardColumns: function () {
        return this._getStates().then({
            success: function (states) {
                return this._buildColumns(states);
            },
            scope: this
        });
    },

    _buildColumns: function (states) {
        if (!states.length) {
            return undefined;
        }

        var columns = [
            {
                columnHeaderConfig: {
                    headerTpl: 'No Entry'
                },
                value: null,
                plugins: ['rallycardboardcollapsiblecolumns'].concat(this.getCardBoardColumnPlugins(null))
            }
        ];

        return columns.concat(_.map(states, function (state) {
            return {
                value: state.get('_ref'),
                wipLimit: state.get('WIPLimit'),
                enableWipLimit: true,
                columnHeaderConfig: {
                    record: state,
                    fieldToDisplay: 'Name',
                    editable: false
                },
                plugins: ['rallycardboardcollapsiblecolumns'].concat(this.getCardBoardColumnPlugins(state))
            };
        }, this));
    },

    _getStates: function () {
        var deferred = new Deft.Deferred();
        Ext.create('Rally.data.wsapi.Store', {
            model: Ext.identityFn('State'),
            context: this.getContext().getDataContext(),
            autoLoad: true,
            fetch: ['Name', 'WIPLimit', 'Description'],
            filters: [
                {
                    property: 'TypeDef',
                    value: this.currentType.get('_ref')
                },
                {
                    property: 'Enabled',
                    value: true
                }
            ],
            sorters: [
                {
                    property: 'OrderIndex',
                    direction: 'ASC'
                }
            ],
            listeners: {
                load: function (store, records) {
                    deferred.resolve(records);
                }
            }
        });
        return deferred.promise;
    },

    getCardBoardColumnPlugins: function (state) {
        return [];
    },

    getCardConfig: function () {
        return {};
    },

    getCardBoardConfig: function (options) {
        options = options || {};
        var currentTypePath = this.currentType.get('TypePath');
        var filters = [];

        if (this.getSetting('query')) {
            try {
                filters.push(Rally.data.QueryFilter.fromQueryString(this.getSetting('query')));
            } catch (e) {
                Rally.ui.notify.Notifier.showError({ message: e.message });
            }
        }

        return {
            attribute: 'State',
            cardConfig: _.merge({
                editable: true,
                showColorIcon: true
            }, this.getCardConfig()),
            columnConfig: {
                xtype: 'rallycardboardcolumn',
                enableWipLimit: true
            },
            columns: options.columns,
            ddGroup: currentTypePath,
            listeners: {
                load: this.publishComponentReady,
                cardupdated: this._publishContentUpdatedNoDashboardLayout,
                scope: this
            },
            plugins: [{ ptype: 'rallyfixedheadercardboard' }],
            storeConfig: {
                filters: filters,
                context: this.getContext().getDataContext()
            }
        };
    },

    getGridStoreConfig: function () {
        return { models: this.piTypePicker.getAllTypeNames() };
    },

    _createPITypePicker: function () {
        if (this.piTypePicker) {
            this.piTypePicker.destroy();
        }

        var deferred = new Deft.Deferred();

        this.piTypePicker = Ext.create('Rally.ui.combobox.PortfolioItemTypeComboBox', {
            preferenceName: 'portfolioitems' + this.stateName + '-typepicker',
            value: this.getSetting('type'),
            context: this.getContext(),
            listeners: {
                change: this._onTypeChange,
                ready: {
                    fn: function (picker) {
                        deferred.resolve(picker.getSelectedType());
                    },
                    single: true
                },
                scope: this
            }
        });

        return deferred.promise;
    },

    _onTypeChange: function (picker) {
        var newType = picker.getSelectedType();

        if (this._pickerTypeChanged(picker)) {
            this.currentType = newType;
            this.modelNames = [newType.get('TypePath')];
            this.gridboard.fireEvent('modeltypeschange', this.gridboard, [newType]);
        }
    },

    _pickerTypeChanged: function(picker){
        var newType = picker.getSelectedType();
        return newType && this.currentType && newType.get('_ref') !== this.currentType.get('_ref');
    },

    _publishContentUpdatedNoDashboardLayout: function () {
        this.fireEvent('contentupdated', { dashboardLayout: false });
    }
});
/**
 * A special cardboard card for use by the PortfolioKanbanApp
 */
Ext.define('Rally.apps.portfoliokanban.PortfolioKanbanCard', {
    extend:'Rally.ui.cardboard.Card',
    alias:'widget.rallyportfoliokanbancard',

    inheritableStatics:{

        getFetchFields:function () {
            return [
                'Owner',
                'FormattedID',
                'Name',
                'StateChangedDate',
                'Blocked',
                'Ready',
                'DisplayColor'
            ];
        }

    },

    config: {
        customFieldConfig: {
            UserStories: {
                fetch: ['UserStories', 'LeafStoryPlanEstimateTotal', 'LeafStoryCount'],
                popoverConfig: {
                    placement: ['bottom', 'right', 'left', 'top'],
                    listViewConfig: {
                        addNewConfig: {
                            showAddWithDetails: false
                        },
                        gridConfig: {
                            columnCfgs: [
                                {
                                    dataIndex: 'FormattedID',
                                    width: 90
                                },
                                {
                                    dataIndex: 'Name',
                                    flex: 1
                                },
                                {
                                    dataIndex: 'Release',
                                    width: 90
                                },
                                {
                                    dataIndex: 'Iteration',
                                    width: 90
                                },
                                {
                                    dataIndex: 'ScheduleState', // 'dataIndex' is the actual field name
                                    text: 'State', // 'text' is the display name
                                    width: 90
                                },
                                {
                                    dataIndex: 'PlanEstimate',
                                    editor: {
                                        decimalPrecision: 0
                                    },
                                    width: 90
                                },
                                {
                                    dataIndex: 'Project',
                                    width: 60
                                }
                            ]
                        }
                    }
                }
            }
        }
    },

    constructor: function(config) {
        config.fields = Ext.Array.union(config.fields || [], ['StateChangedDate']);
        this.callParent(arguments);
    }
});
/**
 * @private
 * Shows the Kanban Policy for a Portfolio Item board, based on the State representing the column.
 * Used by the Rally.ui.cardboard.KanbanColumn
 */
Ext.define('Rally.apps.portfoliokanban.PortfolioKanbanPolicy', {
    extend: 'Rally.ui.cardboard.PolicyContainer',
    alias: 'widget.rallyportfoliokanbanpolicy',

    config: {
        /**
         * @cfg {Rally.data.wsapi.Model} (required)
         * The Kanban State record that holds the policy information.
         */
        stateRecord: undefined
    },

    canEditPolicy: function() {
        return this.getStateRecord().get('updatable');
    },

    getPolicyText: function() {
        return this.getStateRecord() && this.getStateRecord().get('Description');
    },

    draw: function() {
        if (this.getStateRecord()) {
            this.callParent(arguments);
        } else {
            this._drawNotApplicable();
        }
    },

    _drawNotApplicable: function() {
        this.add({
            xtype: 'component',
            renderTpl: '<div class="policyContent">Not Applicable</div>'
        });
    },

    onEditClick: function() {
        Ext.create('Rally.ui.dialog.RichTextDialog', {
            title: 'Edit the Exit Policy for "' + this.getStateRecord().get('Name') + '" Column',
            headerItems: [
                {
                    xtype: 'component',
                    cls: 'kanbanPolicyRichTextEditorHeader',
                    html: 'What needs to be done before an item is ready to leave this column?'
                }
            ],
            autoShow: true,
            record: this.getStateRecord(),
            fieldName: 'Description',
            editorMaxHeight: 500,
            listeners: {
                save: this.drawPolicy,
                scope: this
            }
        });
    }
});

/**
 * Allows configuring of rows for the cardboard
 *
 *
 *      @example
 *      Ext.create('Ext.Container', {
 *          items: [{
 *              xtype: 'rowsettingsfield',
 *              value: {
 *                  show: true,
 *                  field: 'c_ClassofService'
 *              }
 *          }],
 *          renderTo: Ext.getBody().dom
 *      });
 *
 */
Ext.define('Rally.apps.common.RowSettingsField', {
    alias: 'widget.rowsettingsfield',
    extend: 'Ext.form.FieldContainer',
    requires: [
        'Rally.ui.CheckboxField',
        'Rally.ui.combobox.ComboBox',
        'Rally.ui.plugin.FieldValidationUi',
        'Rally.data.ModelFactory',
        'Rally.data.wsapi.ModelBuilder'
    ],

    mixins: {
        field: 'Ext.form.field.Field'
    },

    layout: 'hbox',

    cls: 'row-settings',

    config: {
        /**
         * @cfg {Object}
         *
         * The row settings value for this field
         */
        value: undefined,

        /**
         * @cfg {Function}
         * A function which should return true if the specified field should
         * be included in the list of available swimlane fields
         * @param {Rally.data.wsapi.Field} field
         */
        isAllowedFieldFn: Ext.emptyFn,

        /**
         * @cfg {Object[]}
         *
         * Array of objects with name and value keys to be used by the row combobox
         * [{'name': 'Blocked', 'value': 'Blocked'},{'name': 'Owner', 'value': 'Owner'}]
         */
        explicitFields: [],

        /**
         * @cfg {String[]}
         * Array of models for which to list fields for
         */
        modelNames: ['userstory', 'defect']
    },

    initComponent: function() {
        this.callParent(arguments);

        this.mixins.field.initField.call(this);

        this.add([
            {
                xtype: 'rallycheckboxfield',
                name: 'showRows',
                boxLabel: '',
                margin: '0',
                submitValue: false,
                value: this.getValue().showRows,
                listeners: {
                    change: function(checkbox, checked) {
                        this.down('rallycombobox').setDisabled(!checked);
                    },
                    scope: this
                }
            },
            {
                xtype: 'rallycombobox',
                plugins: ['rallyfieldvalidationui'],
                name: 'rowsField',
                margin: '0 6px',
                width: 130,
                emptyText: 'Choose Field...',
                displayField: 'name',
                valueField: 'value',
                disabled: this.getValue().showRows !== 'true',
                editable: false,
                submitValue: false,
                storeType: 'Ext.data.Store',
                storeConfig: {
                    remoteFilter: false,
                    fields: ['name', 'value'],
                    data: []
                }
            }
        ]);

        this._loadModels();
    },

    _loadModels: function() {
        Rally.data.ModelFactory.getModels({
            types: this.getModelNames(),
            context: this.context,
            success: this._onModelsRetrieved,
            scope: this
        });
    },

    _onModelsRetrieved: function (models) {
        var fields = _.uniq(Ext.Array.merge(this.explicitFields, this._getRowableFields(_.values(models))), 'name');
        var combobox = this.down('rallycombobox');
        combobox.getStore().loadData(_.sortBy(fields, 'name'));
        combobox.setValue(this.getValue().rowsField);
        this.fireEvent('ready', this);
    },

    _getRowableFields: function (models) {
        var artifactModel = Rally.data.wsapi.ModelBuilder.buildCompositeArtifact(models, this.context),
            allFields = artifactModel.getFields(),
            rowableFields = _.filter(allFields, function (field) {
                var attr = field.attributeDefinition;
                return attr && !attr.Hidden && attr.Sortable &&
                    artifactModel.getModelsForField(field).length === models.length &&
                    this.isAllowedFieldFn(field);
            }, this);

        return _.map(rowableFields, function(field) {
            return {
                name: field.displayName,
                value: field.name
            };
        });
    },

    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {},
            showField = this.down('rallycheckboxfield'),
            rowsField = this.down('rallycombobox'),
            showRows = showField.getValue() && !_.isEmpty(rowsField.getValue());
        data[showField.name] = showRows;
        if (showRows) {
            data[rowsField.name] = rowsField.getValue();
        }
        return data;
    },

    refreshWithNewModelType: function(type) {
        this.setModelNames([type]);
        this._loadModels();
    }
});
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>i</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define("TSPortfolioKanbanAlternateField", {
    extend: 'Rally.apps.common.PortfolioItemsGridBoardApp',
    requires: [
        'Rally.apps.common.RowSettingsField',
        'Rally.apps.portfoliokanban.PortfolioKanbanCard',
        'Rally.apps.portfoliokanban.PortfolioKanbanPolicy',
        'Rally.ui.gridboard.plugin.BoardPolicyDisplayable',
        'Rally.ui.cardboard.plugin.ColumnPolicy',
        'Rally.ui.cardboard.Column',
        'Rally.ui.cardboard.Card',
        'Rally.util.Help',
        'Rally.util.Test',
        'Deft.Deferred'
    ],

    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    
    appName: 'Portfolio Kanban',
    autoScroll: false,
    cls: 'portfolio-kanban',
    statePrefix: 'portfolio-kanban',
    toggleState: 'board',
    settingsScope: 'project',

    config: {
        defaultSettings: {
            fields: 'Discussion,PercentDoneByStoryCount,UserStories,Milestones'
        }
    },

    mixins: [
      "Rally.clientmetrics.ClientMetricsRecordable"
    ],

    clientMetrics: [
        {
            method: '_showHelp',
            description: 'portfolio-kanban-show-help'
        }
    ],

    constructor: function(config) {
        config.settingsScope = config.isFullPageApp ? 'project' : 'app';
        this.callParent([config]);
    },

    getSettingsFields: function () {
        var fields = [];

        //if (this.getContext().isFeatureEnabled('S79575_ADD_SWIMLANES_TO_PI_KANBAN')) {
            fields.push({
                name: 'groupHorizontallyByField',
                xtype: 'rowsettingsfield',
                fieldLabel: 'Swimlanes',
                margin: '10 0 10 0',
                mapsToMultiplePreferenceKeys: ['showRows', 'rowsField'],
                readyEvent: 'ready',
                modelNames: ['PortfolioItem'],
                isAllowedFieldFn: function (field) {
                    var attr = field.attributeDefinition;
                    return (attr.Custom && (attr.Constrained || attr.AttributeType.toLowerCase() !== 'string')
                        || attr.Constrained || _.contains(['boolean'], attr.AttributeType.toLowerCase())) &&
                        !_.contains(['web_link', 'text', 'date'], attr.AttributeType.toLowerCase()) &&
                        !_.contains(['Archived', 'Portfolio Item Type', 'State'], attr.Name);
                }
            });
        //}

        fields.push({
            type: 'query',
            config: {
                plugins: [
                    {
                        ptype: 'rallyhelpfield',
                        helpId: 271
                    },
                    'rallyfieldvalidationui'
                ]
            }
        });


        return fields;
    },

    _createFilterItem: function(typeName, config) {
        return Ext.apply({
            xtype: typeName,
            margin: '-15 0 5 0',
            showPills: true,
            showClear: true
        }, config);
    },

    getHeaderControls: function () {
        var ctls = this.callParent(arguments);
        ctls.unshift(this._buildHelpComponent());
        ctls.push(this._buildFilterInfo());
        return ctls;
    },

    getGridBoardPlugins: function () {
        return this.callParent(arguments).concat([{
            ptype: 'rallyboardpolicydisplayable',
            pluginId: 'boardPolicyDisplayable',
            prefKey: 'piKanbanPolicyChecked',
            checkboxConfig: {
                boxLabel: 'Show Policies',
                margin: '2 5 5 5'
            }
        }]);
    },

    getFilterControlConfig: function () {
        var config = this.callParent(arguments);
        return _.merge(config, {
            blackListFields: _.union(config.blackListFields, ['State'])
        });
    },

    getCardConfig: function () {
        return {
            xtype: 'rallyportfoliokanbancard'
        };
    },

    getCardBoardConfig: function () {
        var config = _.merge(this.callParent(arguments), {
            loadDescription: 'Portfolio Kanban'
        });

//        if (this.getSetting('showRows') && this.getSetting('rowsField') &&
//            this.getContext().isFeatureEnabled('S79575_ADD_SWIMLANES_TO_PI_KANBAN')) {
        if (this.getSetting('showRows') && this.getSetting('rowsField')) {
            Ext.apply(config, {
                rowConfig: {
                    field: this.getSetting('rowsField'),
                    sortDirection: 'ASC'
                }
            });
        }

        return config;
    },

    getCardBoardColumnPlugins: function (state) {
        var policyPlugin = this.gridboard && this.gridboard.getPlugin('boardPolicyDisplayable');
        return {
            ptype: 'rallycolumnpolicy',
            policyCmpConfig: {
                xtype: 'rallyportfoliokanbanpolicy',
                hidden: !policyPlugin || !policyPlugin.isChecked(),
                title: 'Exit Policy',
                stateRecord: state
            }
        };
    },

    publishComponentReady: function () {
        this.fireEvent('contentupdated');
        this.callParent(arguments);
        Rally.environment.getMessageBus().publish(Rally.Message.piKanbanBoardReady);
    },

    _buildHelpComponent: function (config) {
        return this.isFullPageApp ? null : Ext.create('Ext.Component', Ext.apply({
            cls: 'help-field ' + Rally.util.Test.toBrowserTestCssClass('portfolio-kanban-help-container'),
            renderTpl: Rally.util.Help.getIcon({
                id: 265
            })
        }, config));
    },

    _buildFilterInfo: function () {
        this.filterInfo = this.isFullPageApp ? null : Ext.create('Rally.ui.tooltip.FilterInfo', {
            projectName: this.getSetting('project') && this.getContext().get('project').Name || 'Following Global Project Setting',
            scopeUp: this.getSetting('projectScopeUp'),
            scopeDown: this.getSetting('projectScopeDown'),
            query: this.getSetting('query')
        });

        return this.filterInfo;
    }
});

            
               Rally.launchApp('TSPortfolioKanbanAlternateField', {
                   name: 'Portfolio Kanban Using Alternate Field'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}

.portfolio-kanban {
    overflow-y: hidden;
}

.portfolio-kanban .no-type-text {
    text-align: center;
}

.portfolio-kanban .typeCombo {
    float: right;
}

.portfolio-kanban .readyIndicator {
    visibility: hidden;
}

.portfolio-kanban .timeInState {
    border-top: 1px dotted #CCC;
    color: #666;
    margin-top: 5px;
    padding-top: 5px;
}

.portfolio-kanban .showPolicies {
    font-family: ProximaNovaSemiBold, Helvetica, Arial;
    font-weight: normal;
    float: right;
    margin: 1px 10px 6px 0;
}

.portfolio-kanban .showPolicies  label {
    position: relative;
    top: 1px;
    margin-top: 0;
    padding-left: 4px;
}

.portfolio-kanban .showPolicies .showPoliciesCheckbox {
    position: relative;
    margin-top: 0;
}

.portfolio-kanban .settingsHeader {
    float: left;
    color: gray;
    padding: 1px 0 0 10px;
}

.portfolio-kanban .settingsHeader b {
    padding-right: 5px;
}

.portfolio-kanban .help-field {
    float: right;
}

.portfolio-kanban .field-picker-btn {
    height: 22px;
    margin-top: 3px;
}
    </style>

</head>
<body></body>
</html>